#!/usr/bin/env python3
#
#   bashex - hexdump an MS-BASIC program
#
#   This understands the MS-BASIC binary file and in-memory format and
#   splits the lines based on where the BASIC lines start, rather than
#   at arbitrary 16-byte intervals.
#

from    os.path  import abspath, dirname, join
from    site  import addsitedir
BASEDIR = dirname(dirname(abspath(__file__)))
if __name__ == '__main__': addsitedir(join(BASEDIR, 'pylib'))

from    argparse  import ArgumentParser
from    struct  import unpack
import  sys

from    bastok.tlines  import BASFile


def eprint(*args):
    ' Print without newline at end. '
    print(*args, end='')

def sprint(n):
    ' Print `n` spaces. '
    print(n * ' ', end='')

def aprint(i_addr):
    ' Print address prefix for line. '
    print('  {:04X}:'.format(i_addr), end='')

def hprint(bs):
    ' Print hexdump bytes, each prefixed by a space. '
    for b in bs:
        print(' {:02X}'.format(b), end='')

def vprint(bs):
    ' Print "visible" characters. '
    print(''.join(list(map(vis, bs))), end='')

def vis(b):
    ' Return "visible" version of character code `b`. '
    if b <= 0x20:       return '⋅'      # control char: dot operator
    if b <  0x7F:       return chr(b)   # printable ASCII: the char itself
    pass;               return '▥'      # token: cross-hatched box

def print_hex_firstline(i_lineno, data):
    ' Print the remainder of the first line after the addr and lineno. '
    hprint(data); sprint(3 * (12 - len(data)))                  # hex
    print('  {:5d} '.format(i_lineno), end=''); vprint(data)    # ASCII
    print()                                                     # EOL

def print_hex_contline(addr, data):
    ' Print continuation lines after the first one. '
    if ARGS.address:    aprint(addr)
    else:               eprint('      :')
    eprint('            ')
    #   hex
    hprint(data); sprint(3 * (12 - len(data)))                  # hex
    eprint('        '); vprint(data)                            # ASCII
    print()                                                     # EOL

def printbasline(i_addr, bf):
    nextaddr = bf.read(2)
    i_nextaddr = unpack('<H', nextaddr)[0]
    if i_nextaddr == 0:
        if ARGS.address:    aprint(i_addr)
        else:               eprint('___END:')
        hprint(nextaddr)
        return None

    lineno = bf.read(2)
    i_lineno = unpack('<H', lineno)[0]
    if ARGS.address:    aprint(i_addr)
    else:               eprint('L{:05d}:'.format(i_lineno))
    hprint(nextaddr)
    hprint(lineno)

    linelen = i_nextaddr - i_addr
    line = bf.read(linelen - 4)      # include trailing $00

    i_curpos = i_addr
    print_hex_firstline(i_lineno, line[:12])
    line = line[12:]; i_curpos += 12
    while len(line) > 0:
        print_hex_contline(i_curpos, line[:12])
        line = line[12:]; i_curpos += 12

    return i_addr + linelen

def parseargs():
    p = ArgumentParser(description='MS-BASIC hexdump')
    arg = p.add_argument
    arg('-a', '--address', action='store_true', help='print memory addresses')
    arg('input', help='input file (required); use `-` for stdin')
    return p.parse_args()

def main():
    if ARGS.input == '-':   f = sys.stdin.buffer
    else:                   f = open(ARGS.input, 'rb')
    bf = BASFile(f.read(), 'MSX')
    f.close()

    eprint('HEADER:')
    hprint(bf.header())
    print()

    #   TODO: The initial current address should be auto-detected from the
    #   next-line address and the first line length, and/or overridden by
    #   a command-line parameter.
    i_addr = bf.addr()
    if i_addr is None:
        i_addr = 0                      # what else can we do?

    #   TODO: This assumes little-endian format. We need to be able to do
    #   big-endian for 6800.
    while True:
        i_nextaddr = printbasline(i_addr, bf)
        if i_nextaddr is None:
            print()
            break
        else:
            i_addr = i_nextaddr

if __name__ == '__main__':
    ARGS = parseargs()
    main()
