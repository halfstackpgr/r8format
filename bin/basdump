#!/usr/bin/env python3
#
#   bashex - hexdump an MS-BASIC program
#
#   This understands the MS-BASIC binary file and in-memory format and
#   splits the lines based on where the BASIC lines start, rather than
#   at arbitrary 16-byte intervals.
#

from    argparse  import ArgumentParser
from    struct  import unpack
import  sys

from    bastok.tlines  import BASFile


def printaddr(i_addr):
    print('  {:04X}: '.format(i_addr), end='')

def vis(b):
    ' Return "visible" version of character code `b`. '
    if b <= 0x20:       return '⋅'      # control char: dot operator
    if b <  0x7F:       return chr(b)   # printable ASCII: the char itself
    pass;               return '▥'      # token: cross-hatched box

def print_hex_firstline(i_lineno, data):
    ' Print the remainder of the first line after the addr and lineno. '
    blank = range(12 - len(data))       # columns without data, if any
    #   hex
    for b in data:  print('{:02X} '.format(b), end='')
    for b in blank: print('   ', end='')
    #   ASCII
    pass;           print(' {:5d} '.format(i_lineno), end='')
    for b in data:  print(vis(b), end='')
    #   done with ine
    print()

def print_hex_contline(addr, data):
    ' Print continuation lines after the first one. '
    blank = range(12 - len(data))       # columns without data, if any
    if ARGS.address:    printaddr(addr)
    else:               print('      : ', end='')
    print('            ', end='')
    #   hex
    for b in data:  print('{:02X} '.format(b), end='')
    for b in blank: print('   ', end='')
    #   ASCII
    print('       ', end='')
    for b in data:  print(vis(b), end='')
    print()

def printbasline(i_addr, bf):
    nextaddr = bf.read(2)
    i_nextaddr = unpack('<H', nextaddr)[0]
    if i_nextaddr == 0:
        if ARGS.address:    printaddr(i_addr)
        else:               print('___END: ', end='')
        print('{:02X} {:02X} '.format(nextaddr[0], nextaddr[1]), end='')
        return None

    lineno = bf.read(2)
    i_lineno = unpack('<H', lineno)[0]
    if ARGS.address:    printaddr(i_addr)
    else:               print('L{:05d}: '.format(i_lineno), end='')
    print('{:02X} {:02X} '.format(nextaddr[0], nextaddr[1]), end='')
    print('{:02X} {:02X} '.format(lineno[0], lineno[1]), end='')

    linelen = i_nextaddr - i_addr
    line = bf.read(linelen - 4)      # include trailing $00

    i_curpos = i_addr
    print_hex_firstline(i_lineno, line[:12])
    line = line[12:]; i_curpos += 12
    while len(line) > 0:
        print_hex_contline(i_curpos, line[:12])
        line = line[12:]; i_curpos += 12

    return i_addr + linelen

def parseargs():
    p = ArgumentParser(description='MS-BASIC hexdump')
    arg = p.add_argument
    arg('-a', '--address', action='store_true', help='print memory addresses')
    arg('input', help='input file (required); use `-` for stdin')
    return p.parse_args()

def eprint(s):
    print(s, end='')

def bprint(bs):
    for b in bs:
        print(' {:02X}'.format(b), end='')

def main():
    if ARGS.input == '-':   f = sys.stdin.buffer
    else:                   f = open(ARGS.input, 'rb')
    bf = BASFile(f.read(), 'MSX')
    f.close()

    eprint('HEADER:')
    bprint(bf.header())
    print()

    #   TODO: The initial current address should be auto-detected from the
    #   next-line address and the first line length, and/or overridden by
    #   a command-line parameter.
    i_addr = bf.addr()
    if i_addr is None:
        i_addr = 0                      # what else can we do?

    #   TODO: This assumes little-endian format. We need to be able to do
    #   big-endian for 6800.
    while True:
        i_nextaddr = printbasline(i_addr, bf)
        if i_nextaddr is None:
            print()
            break
        else:
            i_addr = i_nextaddr

if __name__ == '__main__':
    ARGS = parseargs()
    main()
